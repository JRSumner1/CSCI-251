using System.Diagnostics;

class DiskUsage
{
    // Array to store image file extensions for tracking image files specifically - generated by ChatGPT
    static readonly string[] imageExtensions = {".jpg", ".jpeg", ".png", ".gif", ".bmp", ".tif", ".tiff", ".webp", ".svg", ".ico"};

    // Struct to hold directory info: folder count, file count, total size, image count, image size, and runtime
    struct DirectoryInfo
    {
        public int FolderCount;  // Number of folders found
        public int FileCount;    // Number of files found
        public long TotalSize;   // Total size of all files
        public int ImageCount;   // Number of image files found
        public long ImageSize;   // Total size of image files
        public double RunTime;   // Time taken to process the directory
    }

    // Help Message for when user pass invalid arguments
    static void ErrorMenu()
    {
        Console.WriteLine("Usage: du [-s] [-d] [-b] <path>");
        Console.WriteLine("Summarize disk usage of the set of FILES, recursively for directories.");
        Console.WriteLine("You MUST specify one of the parameters: -s, -d, or -b");
        Console.WriteLine("-s\tRun in single threaded mode");
        Console.WriteLine("-d\tRun in parallel mode (uses all available processors)");
        Console.WriteLine("-b\tRun in both parallel and single threaded mode.");
        Console.WriteLine("\tRuns parallel followed by sequential mode");
    }

    // Output processed info from either single, parallel, or both
    static void OutputInfo(DirectoryInfo directoryInfo, string mode)
    {
        Console.WriteLine($"\n{mode} Calculated in: {directoryInfo.RunTime}s");
        // Displays number of folders, files, and bytes with commas every 1,000
        Console.WriteLine($"{directoryInfo.FolderCount:N0} folders, {directoryInfo.FileCount:N0} files, {directoryInfo.TotalSize:N0} bytes"); 
        
        // Check if images were found
        if (directoryInfo.ImageCount != 0)
        {
            // Displays number of image files and bytes of images with commas every 1,000
            Console.WriteLine($"{directoryInfo.ImageCount:N0} image files, {directoryInfo.ImageSize:N0} bytes");
        }
        else
        {
            Console.WriteLine("No image files found in the directory");
        }
    }

    // Function for processing whether in single, parallel, or both
    static void Process(string path, bool parallel, bool single)
    {
        // If both parallel and single are true, runs parallel first then single
        if (parallel)
        {
            // Starts a timer for runTime
            Stopwatch stopwatch = Stopwatch.StartNew();
            // Calls ProcessDirectory in Parallel and returns struct
            DirectoryInfo parallelInfo = ProcessDirectory(path, true);
            // Stops timer
            stopwatch.Stop();
            // Stores time ran in seconds
            parallelInfo.RunTime = stopwatch.Elapsed.TotalSeconds;
            OutputInfo(parallelInfo, "Parallel");
        }
        if (single)
        {
            // Starts a timer for runTime
            Stopwatch stopwatch = Stopwatch.StartNew();
            // Calls ProcessDirectory in Single and returns struct
            DirectoryInfo singleInfo = ProcessDirectory(path, false);
            // Stops timer
            stopwatch.Stop();
            // Stores time ran in seconds
            singleInfo.RunTime = stopwatch.Elapsed.TotalSeconds;
            OutputInfo(singleInfo, "Sequential");
        }
    }

    // General Function for processing directories and subdirectories, handles parallel and single threading with a flag
    static DirectoryInfo ProcessDirectory(string dirPath, bool useParallel)
    {
        // Initialize new struct
        DirectoryInfo info = new DirectoryInfo();
        object lockObj = new object();  // For thread safety

        // Try-Catch for Error Handling
        try
        {
            // Retrieve and store all files in current directory
            var files = Directory.EnumerateFiles(dirPath);
            if (useParallel)
            {
                Parallel.ForEach(files, file =>
                {
                    // Lock for thread safety when updating shared variables
                    var fileSize = ProcessFile(file, ref info, lockObj);
                    lock (lockObj)
                    {
                        info.FileCount++; // Update FileCount
                        info.TotalSize += fileSize; // Update TotalSize
                    }
                });
            }
            else
            {
                // Sequential processing for files
                foreach (var file in files)
                {
                    var fileSize = ProcessFile(file, ref info, null); // Call without locking threads
                    info.FileCount++; // Update FileCount
                    info.TotalSize += fileSize; // Update TotalSize
                }
            }

            // Retrieve and store all sub-directories in current directory
            var dirs = Directory.GetDirectories(dirPath);
            info.FolderCount += dirs.Length; // Update FolderCount
            if (useParallel)
            {
                // Parallel processing for directories and sub-directories
                Parallel.ForEach(dirs, dir =>
                {
                    // Call ProcessDirectory for sub-directory in parallel
                    var subDirInfo = ProcessDirectory(dir, true);
                    // Lock for thread safety
                    lock (lockObj)
                    {
                        // Call to combine all returned info from sub-directory
                        MergeDirectoryInfo(ref info, subDirInfo);
                    }
                });
            }
            else
            {
                // Sequential processing for sub-directories
                foreach (var dir in dirs)
                {
                    // Call ProcessDirectory for sub-directory in sequential
                    var subDirInfo = ProcessDirectory(dir, false);
                    // Call to combine all returned info from sub-directory
                    MergeDirectoryInfo(ref info, subDirInfo);
                }
            }
        }
        catch (UnauthorizedAccessException) { return info; } // Access Denied Handler
        catch (Exception) { return info; } // All other handlers

        return info; // Return all data from directories
    }

    // Function for processing files and storing in struct
    static long ProcessFile(string filePath, ref DirectoryInfo info, object? lockObj)
    {
        // Try-Catch for Error Handling
        try
        {
            // Retrieve file information
            var fileInfo = new FileInfo(filePath);

            // Check if file is a jpg, jpeg, png, or gif
            if (imageExtensions.Contains(fileInfo.Extension.ToLower()))
            {
                // Check if parallel processing
                if (lockObj != null)
                {
                    // Lock for thread safety
                    lock (lockObj)
                    {
                        info.ImageCount++; // Update ImageCount
                        info.ImageSize += fileInfo.Length; // Update ImageSize
                    }
                }
                else
                {
                    info.ImageCount++; // Update ImageCount
                    info.ImageSize += fileInfo.Length; // Update ImageSize
                }
            }

            return fileInfo.Length; // Return fileSize
        }
        catch (UnauthorizedAccessException) { return 0; } // Access denied handle
        catch (Exception) { return 0; } // All other exceptions handle
    }

    // Function for combining all data recovered for sub-directories and storing in top-level struct objects
    static void MergeDirectoryInfo(ref DirectoryInfo parentInfo, DirectoryInfo subDirInfo)
    {
        parentInfo.FolderCount += subDirInfo.FolderCount; // Update FolderCount with sub-directory FolderCount
        parentInfo.FileCount += subDirInfo.FileCount; // Update FileCount with sub-directory FileCount
        parentInfo.TotalSize += subDirInfo.TotalSize; // Update TotalSize with sub-directory TotalSize
        parentInfo.ImageCount += subDirInfo.ImageCount; // Update ImageCount with sub-directory ImageCount
        parentInfo.ImageSize += subDirInfo.ImageSize; // Update ImageSize with sub-directory ImageSize
    }

    static int Main(string[] args)
    {
        // Check if 2 arguments were passed
        if (args.Length != 2)
        {
            // Call ErrorMenu and exit program
            ErrorMenu();
            return 1;
        }

        // Variables for mode and path
        string mode = args[0];
        string path = args[1];

        // Booleans for setting single or parallel processing
        bool singleThreaded = false;
        bool parallelThreaded = false;

        // Switch-case for checking which flag was passed
        switch (mode)
        {
            case "-s":
                singleThreaded = true;
                break;
            case "-d":
                parallelThreaded = true;
                break;
            case "-b":
                parallelThreaded = true;
                singleThreaded = true;
                break;
            default: // If invalid flag was passed in arguments
                ErrorMenu();
                return 1;
        }

        // Check if directory path exists
        if (Directory.Exists(path))
        {
            // Print Directory
            Console.WriteLine($"Directory '{path}':");
        }
        else
        {
            // Call ErrorMenu and exit program
            ErrorMenu();
            return 1;
        }

        // Call Process for the path and if it is parallel, single, or both
        Process(path, parallelThreaded, singleThreaded);
        
        return 0; // Exit program successfully
    }
}
